---
layout: post
title:  "Blur Backgrounds and Custom Modal Transitions"
date:   19-01-2014
categories: ios objectivec ios7 blur
comments: true
github_fork_url: "https://github.com/sergiocampama/SpringAndBlurDemo"
---

<p>Welcome back! In this post we are going to learn 2 tricks for iOS 7 app development. The first trick lets you present a view that blurs the views behind it, very iOS 7 style. The second one is how to make custom animations for modal view controller presentations and dismissals. I haven't tested it yet, but I'm sure this concepts apply also to push animations as well.</p>

<p>I learnt the basics of this tutorial on <a href="http://ios7.codeschool.com/levels/1">CodeSchool's Core iOS7 course</a>, be sure to check it out! It's a great course to get you up to speed in everything new in iOS7.</p>

<p>This post is accompanied by an iOS Demo app, which you can download/fork/check out/comment <a href="https://github.com/sergiocampama/SpringAndBlurDemo">here</a></p>

<h3>Blurred Backgrounds</h3>

<p>Ok, so there are 2 types of blurred backgrounds:</p>

<ol>
  <li>Static Blur</li>
  <li>Dynamic Blur</li>
</ol>

<p>The static approach consists of rendering the views behind the view for which we want the blurred background. That render is saved to an UIImage and a blur is applied with the UIImage+ImageEffects categories provided by Apple. Finally, the blurred image is set as the background to the view.</p>

<p>The main problem with this approach is that if the background views change, or the view is moved, the blurred background won't update dynamically, which will look awkward.</p>

<h4>The dynamic approach</h4>

<p>This approach is a very cool trick, in which we utilize the dynamic blur effects already implemented in the UIToolbar and UINavigationBar in iOS7. The trick consists of creating a UINavigationBar, setting its frame to the bounds of the bounds of the view we want to give the blurred background, and then inserting the toolbar's layer as the first layer in the view's layer hierarchy. Is your mind blown now?</p>

<pre class="well">
  - (void)viewDidLoad
  {
      [super viewDidLoad];
      
      self.view.backgroundColor = [UIColor clearColor];
      self.lenderBar = [[UINavigationBar alloc] initWithFrame:self.view.bounds];
      self.lenderBar.barStyle = UIBarStyleDefault;
      [self.view.layer insertSublayer:self.lenderBar.layer atIndex:0];
  }
</pre>

<p class="figure">
  <a href="/media/images/blur_modals/1.png" rel="prettyPhoto"><img src="/media/images/blur_modals/1.png" class="img-responsive img-thumbnail"></a><br>
  <small>You can see how the background is blurred in the modal view. In the demo you'll see that it's also dynamic.</small>
</p>

<p>There are some couple of gotchas that are needed in order for this to work with orientation changes, which you can find in the demo's source code.</p>

<h3>Custom Modal Transitions</h3>

<p>So, in order to understand how custom transitions work, we need to understand the way iOS 7 conceptualizes the different components of a custom transition. There are 2 important concepts:</p>

<ol>
  <li>Transitioning Delegate</li>
  <li>Animation Controller</li>
</ol>

<h4>Transitioning Delegate</h4>

<p>The transitioning delegate is the element in charge of providing the correct controllers for the transition animations. This is a property of the modal view controller to be presented.</p>

<pre class="well">
  - (IBAction)showModal:(id)sender
  {
    ModalViewController *controller = [ModalViewController new];
    controller.modalPresentationStyle = UIModalPresentationCustom; // Needed for custom animations to work
    controller.transitioningDelegate = self; //Conforms to the UIViewControllerTransitioningDelegate protocol
  }
</pre>

<p>The <code>UIViewControllerTransitioningDelegate</code> protocol specifies 3 methods:</p>

<ol style="overflow:auto;">
  <li><code>- (id<UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</code></li>
  <li><code>- (id<UIViewControllerAnimatedTransitioning>)animationControllerForDismissedController:(UIViewController *)dismissed</code></li>
  <li><code>- (id<UIViewControllerInteractiveTransitioning>)interactionControllerForPresentation:(id<UIViewControllerAnimatedTransitioning>)animator</code></li>
  <li><code>- (id<UIViewControllerInteractiveTransitioning>)interactionControllerForDismissal:(id<UIViewControllerAnimatedTransitioning>)animator</code></li>
</ol>

<p>I know, those are some very big method names, but they're not that scary. The first one returns an animation controller in charge of the presentation of the modal view controller, while the second one delivers the animation controller that deals with the dismissal of the view controller. The third and fourth methods return an interaction controller, which will be a controller for the animation controllers in situations where you want to let the user interact with the presentation and dismissal transitions.</p>

<h4>Animation Controller</h4>

<p>The animation controller is the element which will implement the animations for the view. It has to conform to the <code>UIViewControllerAnimatedTransitioning</code> protocol, which defines 2 methods that need to be implemented:</p>

<ol>
  <li><code>- (NSTimeInterval)transitionDuration:(id<UIViewControllerContextTransitioning>)transitionContext</code></li>
  <li><code>- (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext</code></li>
</ol>

<p>The first method returns the duration of the transition, which I've seen many times defined to just return <code>1.0</code>. The second method is where the animation controller implements the animation per se.</p>

<p>The <code>transitionContext</code> is where you will get all the necesary elements to complete the animations. For example, for a presenting animation, this context provides you with the presenting view controller, aliased as <code>fromViewController</code> and the modal view controller, aliased as <code>toViewController</code>.</p>

<p>The <code>transitionContext</code> also provides you with a <code>containerView</code>, which is the view where the animations will take place. This view already contains the <code>fromViewController</code>'s view, and the animation controller is expected to add the <code>toViewController</code>'s view into the container view's hierarchy. Finally, to mark the transition as complete, you have to tell the <code>transitionContext</code>.</p>

<p>There are many approaches that can be used to implement the animations, some of which are implemented in the demo. We can define the animations using <code>UIView</code>'s animations with block methods, as shown in the following example.</p>

<pre class="well" style="">
  - (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext
  {
      UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
      UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
      
      CGRect fromVCFrame = [transitionContext initialFrameForViewController:fromVC];
      
      CGRect finalFrame = CGRectMake(20, 20, CGRectGetWidth(fromVCFrame) - 40, CGRectGetHeight(fromVCFrame) - 40);
      
      CGRect initialFrame = [self initialFrameFromFinalFrame:finalFrame inTransitionContext:transitionContext];
      
      toVC.view.frame = initialFrame;
      [[transitionContext containerView] addSubview:toVC.view];
      
      [UIView animateWithDuration:[self transitionDuration:transitionContext]
                            delay:0.0f
           usingSpringWithDamping:0.5f
            initialSpringVelocity:0.6f
                          options:UIViewAnimationOptionCurveEaseInOut
                       animations:^{
                           toVC.view.frame = finalFrame;
                       }
                       completion:^(BOOL finished) {
                           [transitionContext completeTransition:YES];
                       }];
  }
</pre>

<p>Another way of animating the views is using the new <code>UIDynamicAnimator</code> and company of <code>UIDynamicBehaviour</code>s, which are a really cool feature to animate views with familiar effects like <code>UIGravityBehaviour</code>.</p>

<p>Well, I think that covers the concepts necessary to understand the demo and learn more from it. The demo also contains the implementation of the interaction controller for dismissal mechanic, which allows the user to control the pace of the animation using his fingers. Please leave a comment if you have any questions!</p>

<script>
  $(function(){
    $("a[rel^='prettyPhoto']").prettyPhoto();
  });
</script>